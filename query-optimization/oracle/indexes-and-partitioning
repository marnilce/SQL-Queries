/*
================================================================================
QUERY OPTIMIZATION: Indexes and Partitioning Strategies
================================================================================

⚠️ DISCLAIMER: This is a simulated example for educational purposes.
   All queries, table structures, and data are fictional and do not 
   represent actual production code or proprietary information.

Database: Oracle
Context: Streaming and Pay-TV Platform Analytics (Simulated Scenario)
Scenario: Large user activity table with date-based behavioral queries
Problem: Full table scans on 100M+ records causing performance issues
Solution: Implement proper indexing and table partitioning

Performance Improvement: ~96% faster query execution
Dataset: 100M+ user activity events, real-time analytics for marketing
Use Cases: Campaign Performance, User Engagement, Churn Prevention
================================================================================
*/

-- ============================================================================
-- SCENARIO: User Activity Events Table
-- ============================================================================

/*
Table Structure:
- 100+ million user activity events
- Growing 3-5M events daily (streaming + cable TV)

- Main use cases:
  1. Marketing: Campaign performance and user acquisition
  2. Product: Content engagement and user behavior
  3. Retention: Churn prediction and intervention
- Most queries filter by event date, user segments, content type
- Real-time dashboards require fast query response
*/

CREATE TABLE user_activity_events (
    event_id                NUMBER(18) PRIMARY KEY,
    user_id                 VARCHAR2(50) NOT NULL,
    event_date              DATE NOT NULL,
    event_timestamp         TIMESTAMP NOT NULL,
    event_type              VARCHAR2(30) NOT NULL,  -- LOGIN, PLAY, PAUSE, STOP, SEARCH
    platform_type           VARCHAR2(20) NOT NULL,  -- STREAMING, CABLE_TV
    device_type             VARCHAR2(30),           -- MOBILE, WEB, TV, STB
    content_id              VARCHAR2(50),
    content_type            VARCHAR2(20),           -- MOVIE, SERIES, LIVE, SPORTS
    content_genre           VARCHAR2(30),
    session_duration_sec    NUMBER(10),
    user_segment            VARCHAR2(30),           -- NEW, ACTIVE, AT_RISK, CHURNED
    subscription_plan       VARCHAR2(30),           -- BASIC, PREMIUM, SPORTS
    campaign_id             VARCHAR2(50),
    marketing_channel       VARCHAR2(30),           -- PAID_SOCIAL, EMAIL, ORGANIC
    country_code            VARCHAR2(5),
    created_date            TIMESTAMP DEFAULT SYSTIMESTAMP
);


-- ============================================================================
-- PROBLEM: Query Performance WITHOUT Optimization
-- ============================================================================

-- Use Case: Marketing Team - Campaign performance analysis
-- Typical query: Last 30 days engagement by campaign and channel
-- Execution Time: ~75 seconds
-- Consistent Gets: 4.5M+

SELECT 
    campaign_id,
    marketing_channel,
    platform_type,
    COUNT(DISTINCT user_id) AS unique_users,
    COUNT(*) AS total_events,
    SUM(CASE WHEN event_type = 'PLAY' THEN 1 ELSE 0 END) AS play_events,
    AVG(session_duration_sec) AS avg_session_duration,
    COUNT(DISTINCT CASE WHEN event_type = 'LOGIN' THEN user_id END) AS active_users
FROM 
    user_activity_events
WHERE 
    event_date >= TRUNC(SYSDATE) - 30
    AND campaign_id IS NOT NULL
    AND platform_type = 'STREAMING'
GROUP BY 
    campaign_id,
    marketing_channel,
    platform_type
ORDER BY 
    unique_users DESC;

/*
EXPLAIN PLAN (Without Optimization):
---------------------------------------------------------------------------
| Id  | Operation                    | Name                   | Rows   | Cost  |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |                        |   200  | 85000 |
|   1 |  SORT GROUP BY              |                        |   200  | 85000 |
|*  2 |   TABLE ACCESS FULL         | USER_ACTIVITY_EVENTS   | 5000K  | 84500 |
---------------------------------------------------------------------------

Predicate Information:
   2 - filter("EVENT_DATE">=TRUNC(SYSDATE@!)-30 AND 
              "CAMPAIGN_ID" IS NOT NULL AND "PLATFORM_TYPE"='STREAMING')

Problem: Full table scan on 100M records to aggregate 5M matching rows!
Business Impact: Marketing dashboards take over 1 minute to load
*/


-- ============================================================================
-- SOLUTION 1: Strategic Index Creation for Streaming Analytics
-- ============================================================================

/*
INDEX STRATEGY - Streaming Platform Considerations:
1. High query volume from Marketing, Product, and Data Science teams
2. Date range queries are dominant (daily/weekly/monthly analysis)
3. User-level analysis requires fast user_id lookups
4. Content engagement queries need content_id access
5. Real-time dashboards require sub-second query response
6. Balance read performance vs write overhead (3-5M inserts daily)
*/

-- Composite index for date-based campaign analysis (most common)
-- Used by: Marketing for campaign performance tracking
CREATE INDEX idx_events_date_campaign_platform
ON user_activity_events(event_date, campaign_id, platform_type)
TABLESPACE index_ts
COMPUTE STATISTICS;

-- Index for user behavior analysis
-- Used by: Product and Retention teams for user journey analysis
CREATE INDEX idx_events_user_date_type
ON user_activity_events(user_id, event_date, event_type)
TABLESPACE index_ts
COMPUTE STATISTICS;

-- Index for content engagement analysis
-- Used by: Content team for popularity and engagement metrics
CREATE INDEX idx_events_content_date
ON user_activity_events(content_id, event_date, event_type)
TABLESPACE index_ts
COMPUTE STATISTICS;

-- Composite index for churn analysis
-- Used by: Retention team for at-risk user identification
CREATE INDEX idx_events_segment_date
ON user_activity_events(user_segment, event_date, platform_type)
TABLESPACE index_ts
COMPUTE STATISTICS;

-- Bitmap index for low-cardinality columns (analytics workload)
CREATE BITMAP INDEX idx_events_platform_bmp
ON user_activity_events(platform_type)
TABLESPACE index_ts;

CREATE BITMAP INDEX idx_events_event_type_bmp
ON user_activity_events(event_type)
TABLESPACE index_ts;

CREATE BITMAP INDEX idx_events_device_bmp
ON user_activity_events(device_type)
TABLESPACE index_ts;


-- ============================================================================
-- SOLUTION 2: Table Partitioning for Streaming Data
-- ============================================================================

/*
PARTITIONING BENEFITS FOR STREAMING PLATFORM:
1. Partition pruning: Access only relevant time periods (huge performance gain)
2. Easier data lifecycle management: Archive old data efficiently
3. Improved concurrency: Different teams query different partitions
4. Parallel processing: Distribute analytical workload
5. Simplified ETL: Load data into specific partitions
6. Cost optimization: Move old partitions to cheaper storage

PARTITION STRATEGY: Range partitioning by day
- Most queries filter by recent periods (last 7/30/90 days)
- Daily partitions allow fine-grained data management
- Historical data (>90 days) can be compressed
*/

-- Step 1: Create partitioned table structure
CREATE TABLE user_activity_events_partitioned (
    event_id                NUMBER(18),
    user_id                 VARCHAR2(50) NOT NULL,
    event_date              DATE NOT NULL,
    event_timestamp         TIMESTAMP NOT NULL,
    event_type              VARCHAR2(30) NOT NULL,
    platform_type           VARCHAR2(20) NOT NULL,
    device_type             VARCHAR2(30),
    content_id              VARCHAR2(50),
    content_type            VARCHAR2(20),
    content_genre           VARCHAR2(30),
    session_duration_sec    NUMBER(10),
    user_segment            VARCHAR2(30),
    subscription_plan       VARCHAR2(30),
    campaign_id             VARCHAR2(50),
    marketing_channel       VARCHAR2(30),
    country_code            VARCHAR2(5),
    created_date            TIMESTAMP DEFAULT SYSTIMESTAMP,
    CONSTRAINT pk_events_part PRIMARY KEY (event_id, event_date)
)
PARTITION BY RANGE (event_date)
INTERVAL (NUMTODSINTERVAL(1, 'DAY'))  -- Automatic daily partitions
(
    -- Initial partitions
    PARTITION p_2024_01_01 VALUES LESS THAN (TO_DATE('2024-01-02', 'YYYY-MM-DD')),
    PARTITION p_2024_01_02 VALUES LESS THAN (TO_DATE('2024-01-03', 'YYYY-MM-DD')),
    PARTITION p_2024_01_03 VALUES LESS THAN (TO_DATE('2024-01-04', 'YYYY-MM-DD'))
)
ENABLE ROW MOVEMENT;


-- Step 2: Create local indexes on partitioned table
-- Local indexes: Each daily partition has its own index segment

-- Local index for user analysis
CREATE INDEX idx_events_part_user
ON user_activity_events_partitioned(user_id, event_type)
LOCAL
TABLESPACE index_ts;

-- Local composite for campaign analysis
CREATE INDEX idx_events_part_campaign
ON user_activity_events_partitioned(campaign_id, marketing_channel, platform_type)
LOCAL
TABLESPACE index_ts;

-- Local index for content analysis
CREATE INDEX idx_events_part_content
ON user_activity_events_partitioned(content_id, content_type)
LOCAL
TABLESPACE index_ts;

-- Local bitmap indexes for dimensional analysis
CREATE BITMAP INDEX idx_events_part_platform_bmp
ON user_activity_events_partitioned(platform_type)
LOCAL
TABLESPACE index_ts;

CREATE BITMAP INDEX idx_events_part_segment_bmp
ON user_activity_events_partitioned(user_segment)
LOCAL
TABLESPACE index_ts;


-- Step 3: Global index for cross-period user history
CREATE INDEX idx_events_part_global_user
ON user_activity_events_partitioned(user_id, event_date, event_type)
GLOBAL
TABLESPACE index_ts;


-- ============================================================================
-- PERFORMANCE COMPARISON: Same Query with Optimizations
-- ============================================================================

-- Query on NON-PARTITIONED table with indexes
SELECT 
    campaign_id,
    marketing_channel,
    platform_type,
    COUNT(DISTINCT user_id) AS unique_users,
    COUNT(*) AS total_events,
    SUM(CASE WHEN event_type = 'PLAY' THEN 1 ELSE 0 END) AS play_events,
    AVG(session_duration_sec) AS avg_session_duration,
    COUNT(DISTINCT CASE WHEN event_type = 'LOGIN' THEN user_id END) AS active_users
FROM 
    user_activity_events
WHERE 
    event_date >= TRUNC(SYSDATE) - 30
    AND campaign_id IS NOT NULL
    AND platform_type = 'STREAMING'
GROUP BY 
    campaign_id,
    marketing_channel,
    platform_type
ORDER BY 
    unique_users DESC;

/*
EXPLAIN PLAN (With Indexes, Non-Partitioned):
---------------------------------------------------------------------------
| Id  | Operation                         | Name                            | Rows  | Cost |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT                 |                                 |  200  |  850 |
|   1 |  SORT GROUP BY                   |                                 |  200  |  850 |
|*  2 |   TABLE ACCESS BY INDEX ROWID    | USER_ACTIVITY_EVENTS            | 5000K |  820 |
|*  3 |    INDEX RANGE SCAN              | IDX_EVENTS_DATE_CAMPAIGN_PLATFORM| 5000K |  150 |
---------------------------------------------------------------------------

Performance: ~4 seconds (94% improvement from 75 seconds)
Consistent Gets: ~180K (96% reduction from 4.5M)
*/


-- Query on PARTITIONED table with local indexes
SELECT 
    campaign_id,
    marketing_channel,
    platform_type,
    COUNT(DISTINCT user_id) AS unique_users,
    COUNT(*) AS total_events,
    SUM(CASE WHEN event_type = 'PLAY' THEN 1 ELSE 0 END) AS play_events,
    AVG(session_duration_sec) AS avg_session_duration,
    COUNT(DISTINCT CASE WHEN event_type = 'LOGIN' THEN user_id END) AS active_users
FROM 
    user_activity_events_partitioned
WHERE 
    event_date >= TRUNC(SYSDATE) - 30
    AND campaign_id IS NOT NULL
    AND platform_type = 'STREAMING'
GROUP BY 
    campaign_id,
    marketing_channel,
    platform_type
ORDER BY 
    unique_users DESC;

/*
EXPLAIN PLAN (With Partitioning + Local Indexes):
---------------------------------------------------------------------------
| Id  | Operation                         | Name                        | Rows  | Cost | Pstart | Pstop |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT                 |                             |  200  |  180 |        |       |
|   1 |  SORT GROUP BY                   |                             |  200  |  180 |        |       |
|   2 |   PARTITION RANGE ITERATOR       |                             | 5000K |  160 |    336 |   365 |
|*  3 |    TABLE ACCESS BY LOCAL INDEX   | USER_ACTIVITY_EVENTS_PART   | 5000K |  160 |    336 |   365 |
|*  4 |     INDEX RANGE SCAN             | IDX_EVENTS_PART_CAMPAIGN    | 5000K |   45 |    336 |   365 |
---------------------------------------------------------------------------

Performance: ~1.2 seconds (98% improvement from 75 seconds)
Consistent Gets: ~25K (99.4% reduction from 4.5M)
Partition Pruning: Only 30 partitions accessed (336-365) out of 365 total!
Business Impact: Real-time marketing dashboards, instant campaign insights
*/


-- ============================================================================
-- STREAMING PLATFORM SPECIFIC QUERIES
-- ============================================================================

-- Marketing: Daily active users by platform and subscription plan
SELECT 
    TRUNC(event_date) AS activity_date,
    platform_type,
    subscription_plan,
    COUNT(DISTINCT user_id) AS daily_active_users,
    COUNT(DISTINCT CASE WHEN event_type = 'PLAY' THEN user_id END) AS engaged_users,
    AVG(session_duration_sec) AS avg_session_duration
FROM 
    user_activity_events_partitioned
WHERE 
    event_date >= TRUNC(SYSDATE) - 7
    AND event_type IN ('LOGIN', 'PLAY', 'SEARCH')
GROUP BY 
    TRUNC(event_date),
    platform_type,
    subscription_plan
ORDER BY 
    activity_date DESC,
    daily_active_users DESC;


-- Product: Content engagement by genre and device
SELECT 
    content_genre,
    device_type,
    COUNT(DISTINCT user_id) AS unique_viewers,
    COUNT(*) AS total_plays,
    SUM(session_duration_sec) / 3600 AS total_hours_watched,
    AVG(session_duration_sec) / 60 AS avg_watch_time_minutes
FROM 
    user_activity_events_partitioned
WHERE 
    event_date >= TRUNC(SYSDATE) - 30
    AND event_type = 'PLAY'
    AND content_type IN ('MOVIE', 'SERIES')
GROUP BY 
    content_genre,
    device_type
ORDER BY 
    total_hours_watched DESC;


-- Retention: Churn risk identification
SELECT 
    user_id,
    user_segment,
    subscription_plan,
    MAX(event_date) AS last_activity_date,
    TRUNC(SYSDATE) - MAX(event_date) AS days_inactive,
    COUNT(DISTINCT TRUNC(event_date)) AS active_days_last_30,
    AVG(session_duration_sec) AS avg_session_duration
FROM 
    user_activity_events_partitioned
WHERE 
    event_date >= TRUNC(SYSDATE) - 30
    AND user_segment IN ('ACTIVE', 'AT_RISK')
GROUP BY 
    user_id,
    user_segment,
    subscription_plan
HAVING 
    MAX(event_date) < TRUNC(SYSDATE) - 7  -- No activity in last 7 days
    AND COUNT(DISTINCT TRUNC(event_date)) < 10  -- Less than 10 active days
ORDER BY 
    days_inactive DESC;


-- Campaign Performance: Conversion funnel analysis
SELECT 
    campaign_id,
    marketing_channel,
    COUNT(DISTINCT user_id) AS total_users,
    COUNT(DISTINCT CASE WHEN event_type = 'LOGIN' THEN user_id END) AS logins,
    COUNT(DISTINCT CASE WHEN event_type = 'SEARCH' THEN user_id END) AS searches,
    COUNT(DISTINCT CASE WHEN event_type = 'PLAY' THEN user_id END) AS plays,
    ROUND(COUNT(DISTINCT CASE WHEN event_type = 'PLAY' THEN user_id END) * 100.0 / 
          NULLIF(COUNT(DISTINCT user_id), 0), 2) AS conversion_rate
FROM 
    user_activity_events_partitioned
WHERE 
    event_date >= TRUNC(SYSDATE) - 30
    AND campaign_id IS NOT NULL
GROUP BY 
    campaign_id,
    marketing_channel
ORDER BY 
    conversion_rate DESC;


-- ============================================================================
-- PARTITION MAINTENANCE - Streaming Data Lifecycle
-- ============================================================================

-- View recent partitions and their sizes
SELECT 
    partition_name,
    high_value,
    num_rows,
    blocks,
    ROUND(blocks * 8 / 1024, 2) AS size_mb,
    compression,
    last_analyzed
FROM 
    user_tab_partitions
WHERE 
    table_name = 'USER_ACTIVITY_EVENTS_PARTITIONED'
    AND partition_position >= (
        SELECT MAX(partition_position) - 30 
        FROM user_tab_partitions 
        WHERE table_name = 'USER_ACTIVITY_EVENTS_PARTITIONED'
    )
ORDER BY 
    partition_position DESC;


-- Compress partitions older than 90 days (historical analysis only)
ALTER TABLE user_activity_events_partitioned
MODIFY PARTITION p_2024_09_01 COMPRESS FOR QUERY HIGH;


-- Archive and drop partitions older than 2 years
CREATE TABLE user_activity_archive_2023_q1
AS SELECT * FROM user_activity_events_partitioned 
   PARTITION (p_2023_01_01);

ALTER TABLE user_activity_events_partitioned 
DROP PARTITION p_2023_01_01;


-- ============================================================================
-- BEST PRACTICES FOR STREAMING PLATFORM ANALYTICS
-- ============================================================================

/*
STREAMING DATA SPECIFIC CONSIDERATIONS:

1. REAL-TIME REQUIREMENTS
   - Marketing dashboards need sub-second response times
   - Use materialized views for frequently accessed aggregations
   - Consider result caching for repeated queries

2. DATA FRESHNESS vs PERFORMANCE
   - Balance between real-time inserts and query performance
   - Batch inserts during off-peak hours when possible
   - Use direct-path inserts for bulk loads

3. HOT vs COLD DATA
   - Recent 30 days = HOT (fast storage, no compression)
   - 30-90 days = WARM (moderate compression)
   - 90+ days = COLD (high compression, archive storage)

4. PARTITION STRATEGY
   - Daily partitions for fine-grained management
   - Automatic partition creation with INTERVAL
   - Regular maintenance to drop/archive old data

5. INDEX SELECTIVITY
   - High cardinality: user_id, event_id, content_id
   - Medium cardinality: campaign_id, device_type
   - Low cardinality: platform_type, event_type (use bitmap)

6. QUERY PATTERNS
   - Most queries filter by recent dates (last 7/30/90 days)
   - Campaign analysis needs date + campaign_id
   - User journey needs user_id + date range
   - Content engagement needs content_id + date range

7. MONITORING AND OPTIMIZATION
   - Track query performance by team/use case
   - Identify and optimize slow queries weekly
   - Rebuild fragmented indexes monthly
   - Update statistics after major data loads
*/


-- ============================================================================
-- MONITORING QUERIES FOR STREAMING ANALYTICS
-- ============================================================================

-- Daily event volume tracking (detect anomalies)
SELECT 
    TRUNC(event_date) AS event_date,
    platform_type,
    COUNT(*) AS total_events,
    COUNT(DISTINCT user_id) AS unique_users,
    COUNT(DISTINCT session_id) AS unique_sessions,
    ROUND(COUNT(*) * 1.0 / NULLIF(COUNT(DISTINCT user_id), 0), 2) AS events_per_user
FROM 
    user_activity_events_partitioned
WHERE 
    event_date >= TRUNC(SYSDATE) - 7
GROUP BY 
    TRUNC(event_date),
    platform_type
ORDER BY 
    event_date DESC;


-- Partition growth monitoring
SELECT 
    TO_CHAR(TO_DATE(SUBSTR(partition_name, 3, 10), 'YYYY_MM_DD'), 'YYYY-MM') AS month,
    COUNT(*) AS partitions_count,
    SUM(num_rows) AS total_rows,
    ROUND(SUM(blocks * 8) / 1024 / 1024, 2) AS total_size_gb
FROM 
    user_tab_partitions
WHERE 
    table_name = 'USER_ACTIVITY_EVENTS_PARTITIONED'
GROUP BY 
    TO_CHAR(TO_DATE(SUBSTR(partition_name, 3, 10), 'YYYY_MM_DD'), 'YYYY-MM')
ORDER BY 
    month DESC;


-- Index usage efficiency
SELECT 
    i.index_name,
    i.blevel AS tree_depth,
    i.leaf_blocks,
    i.num_rows,
    i.distinct_keys,
    ROUND(i.clustering_factor / NULLIF(i.num_rows, 0) * 100, 2) AS cluster_pct,
    i.last_analyzed
FROM 
    user_indexes i
WHERE 
    i.table_name = 'USER_ACTIVITY_EVENTS_PARTITIONED'
ORDER BY 
    i.num_rows DESC;


/*
================================================================================
PERFORMANCE RESULTS SUMMARY - STREAMING PLATFORM
================================================================================

Optimization         | Execution Time | Consistent Gets | Business Impact
---------------------|----------------|-----------------|------------------
No Optimization      | 75 sec         | 4.5M           | Slow dashboards
With Indexes         | 4 sec          | 180K           | Acceptable speed
With Partitioning    | 1.2 sec        | 25K            | Real-time analytics

OPERATIONAL BENEFITS:
- Marketing Team: Real-time campaign performance tracking
- Product Team: Instant user behavior and content engagement analysis
- Retention Team: Proactive churn identification and intervention
- Data Science: Fast experimentation and model training
- Executive Dashboards: Sub-second response for strategic decisions

STORAGE & DATA MANAGEMENT:
- Partition pruning: Access only 30 of 365 partitions (92% data skipped)
- Compression: Older partitions use 25-30% of original space
- Archival: Efficient historical data management
- Cost optimization: Move cold data to cheaper storage tiers

SCALABILITY:
- Handles 3-5M events per day without performance degradation
- Supports concurrent queries from multiple teams
- Linear scalability with partition-wise processing
- Future-proof architecture for growth

KEY TAKEAWAY FOR STREAMING PLATFORMS:
Proper indexing and partitioning enable real-time analytics on massive 
datasets. These optimizations transform marketing intelligence, allowing 
teams to make data-driven decisions instantly rather than waiting minutes 
for queries to complete.

Performance improvements translate directly to better user acquisition,
engagement optimization, and churn prevention.
================================================================================
*/
